Next token is: 11, Next lexeme is a
Enter <or_test>
Enter <and_test>
Enter <not_test>
Enter <comparison>
Enter <expr>
Enter <xor_expr>
Enter <and_expr>
Enter <shift_expr>
Enter <arith_expr>
Enter <term>
Enter <factor>
Enter <power>
Enter <atom>
Next token is: 21, Next lexeme is +
Exit <atom>
Exit <power>
Exit <factor>
Exit <term>
Next token is: 11, Next lexeme is Falsea
Enter <term>
Enter <factor>
Enter <power>
Enter <atom>
Next token is: 30, Next lexeme is **
Exit <atom>
Next token is: 25, Next lexeme is (
Enter <factor>
Enter <power>
Enter <atom>
Next token is: 10, Next lexeme is 100
Enter <or_test>
Enter <and_test>
Enter <not_test>
Enter <comparison>
Enter <expr>
Enter <xor_expr>
Enter <and_expr>
Enter <shift_expr>
Enter <arith_expr>
Enter <term>
Enter <factor>
Enter <power>
Enter <atom>
Next token is: 24, Next lexeme is /
Exit <atom>
Exit <power>
Exit <factor>
Next token is: 14, Next lexeme is None
Enter <factor>
Enter <power>
Enter <atom>
Next token is: 26, Next lexeme is )
Exit <atom>
Exit <power>
Exit <factor>
Exit <term>
Exit <arith_expr>
Exit <shift_expr>
Exit <and_expr>
Exit <xor_expr>
Exit <expr>
Exit <comparison>
Exit <not_test>
Exit <and_test>
Exit <or_test>
Next token is: -1, Next lexeme is EOF
Exit <atom>
Exit <power>
Exit <factor>
Exit <power>
Exit <factor>
Exit <term>
Exit <arith_expr>
Exit <shift_expr>
Exit <and_expr>
Exit <xor_expr>
Exit <expr>
Exit <comparison>
Exit <not_test>
Exit <and_test>
Exit <or_test>
Parsing successful! No errors encountered.
